#tag ClassProtected Class ZipThreadInherits ThreadImplements ZipProgressNotifier	#tag Event		Sub Run()		  if doCompress then		    compressTask		  else		    decompressTask		  end		  IF NOT DoingEncrypt Then		    enc.FinishDecrypt		  END IF		  return		  		Exception exc as RuntimeException		  		End Sub	#tag EndEvent	#tag Method, Flags = &h0		Sub Compress(zar as ZipArchive, source() as FolderItem, followAliases as Boolean, mb_mode as Integer, caller as BCEncryptor)		  Dim i as short		  me.zar = zar		  Redim Me.source(-1)		  For i = 0 to UBound(Source)		    me.source.Append(source(i))		  Next i		  		  me.followAliases = followAliases		  me.mb_mode = mb_mode		  me.doCompress = true		  me.Caller = caller		  		  me.Run		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Decompress(zar as ZipArchive, dest as FolderItem, decodeMacBinary as Boolean)		  me.zar = zar		  me.dest = dest		  me.decodeMacBinary = decodeMacBinary		  me.doCompress = false		  		  me.Run		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub compressTask()		  dim entry as ZipEntry		  dim i, x as Integer		  dim hadError as Boolean		  dim total as Double		  		  		  //		  // Add the immediate item to the archive		  //		  		  For x = 0 to UBound(Me.Source)		    if not hadError then		      i = zar.AddItemToRoot(source(x), mb_mode)		      if i <= 0 then		        showError zar.ErrorMessage		        hadError = true		      else		        entry = zar.Entry(i)		      end		    end		    		    //		    // If the item was a folder, add all its contents, too		    //		    		    if not hadError and source(x).Directory then		      // add the folder contents to the archive		      if not zar.AddFolderContents(source(x), entry.RawPath, mb_mode, followAliases) then		        showError zar.ErrorMessage		        hadError = true		      end		    end		  Next x		  		  //		  // Close the archive		  //		  		  if not zar.Close then		    if not hadError then		      showError zar.ErrorMessage		    end		  end		  		  If Not Me.Caller.EncryptTask Then		    MsgBox "There was an error."		  End If		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub decompressTask()		  dim e as ZipEntry		  dim i as Integer		  dim nameOverflow as Boolean		  dim totalBytes as Double		  dim f as FolderItem		  		  //		  // Calculate the sum of all bytes of all files to extract		  //		  		  totalBytes = 0		  for i = 1 to zar.EntryCount		    e = zar.Entry(i)		    totalBytes = totalBytes + e.Size		  next		  		  me.setTotal totalBytes		  		  //		  // Now extract all items into that folder		  //		  		  for i = 1 to zar.EntryCount		    e = zar.Entry(i)		    		    // optional check to support older or incorrectly created MacBinary headers:		    'if me.decodeMacBinary and Right(e.RawPath(),4) = ".bin" then		    'e.EnableMacBinary1Detection(true)		    'end		    		    f = e.MakeDestination(dest,false)		    if not e.Extract(f, me.decodeMacBinary) then		      showError "Extraction of """+e.RawPath+""" failed: "+e.ErrorMessage		      return		    elseif TargetMacOS and Len(f.Name) <> Len(f.DisplayName) then		      // Note: I (TT) am not 100% sure that the above test is always detecting		      // an overflow when having non-ASCII chars in file names.		      nameOverflow = true		    end		  next		  		  //		  // Close the archive (not really necessary, though)		  //		  		  if not zar.Close then		    showError zar.ErrorMessage		  elseif nameOverflow then		    'showError "One or more extracted files may have truncated names because they were longer than 31 bytes"		  end		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub setTotal(bytes as Double)		  me.total = bytes		  me.finished = 0		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub zipProgress(entry As ZipEntry, totalBytes As Integer, finishedBytes As Integer, ByRef abort As Boolean)		  dim wantsAbort as Boolean, s as String		  if entry <> nil then		    s = entry.RawPath		  end		  if totalBytes = finishedBytes then		    me.finished = me.finished + totalBytes		  end		  if wantsAbort then		    abort = true		  end		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub showError(msg as String)		  // Note: if you want to show a more sophisticated error		  // msg here, you should make sure it also works under		  // Windows. I (TT) found very ugly bugs in RB around		  // accessing windows from within Threads, so you may need		  // to use a Timer that will open the error showing window		  // in order to solve this.		  		  MsgBox msg		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ZipFileError(f As FolderItem, errCode As Integer, errMsg As String, ByRef abort As Boolean)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ZipFileStarting(f As FolderItem, ByRef abort As Boolean)		  		End Sub	#tag EndMethod	#tag Note, Name = About				This class is used to make sure that the modal ProgressWin		gets closed in any case when it's not used any more.				If we'd not use this class, we would have to have make sure		that the code opening this window will not miss any		case where it might prematurely abort the archiving		process.				This class will close the window in its destructor. The		destructor is surely called as long as it's not stored in		a non-local variable.				Besides this, it also implements the ZipProgressNotifier		interface to receive the progress events.					#tag EndNote	#tag Property, Flags = &h1		Protected doCompress As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected zar As ZipArchive	#tag EndProperty	#tag Property, Flags = &h1		Protected dest As FolderItem	#tag EndProperty	#tag Property, Flags = &h1		Protected followAliases As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected mb_mode As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected encoding As TextEncoding	#tag EndProperty	#tag Property, Flags = &h1		Protected source() As FolderItem	#tag EndProperty	#tag Property, Flags = &h1		Protected decodeMacBinary As Boolean	#tag EndProperty	#tag Property, Flags = &h1		Protected finished As Double	#tag EndProperty	#tag Property, Flags = &h1		Protected total As Double	#tag EndProperty	#tag Property, Flags = &h1		Protected caller As BCEncryptor	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="ControlOrder"			Visible=true			Group="Position"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Priority"			Visible=true			Group="Behavior"			InitialValue="5"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="StackSize"			Visible=true			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass