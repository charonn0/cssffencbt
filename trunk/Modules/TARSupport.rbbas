#tag ModuleProtected Module TARSupport	#tag Method, Flags = &h0		Sub UnTAR(extends f as FolderItem)		  // The TAR format is laid out in 512 byte blocks.  So we want		  // to read the file in, 512 bytes at a time, so that we can decipher it		  // All of the fields are strings, so we don't have to worry about endian		  // issues. Yay!		  dim bs as BinaryStream = f.OpenAsBinaryFile( false )		  if bs = nil then return		  		  // Sometime we need to keep track of long paths and file		  // names.  We do that by using this variable.  If we got a long		  // link name, then name will contain the actual data.  This		  // variable is reset each time we get a directory or file block.		  dim name as String		  while not bs.EOF		    // Read in the header		    dim block as Header		    block.StringValue( TargetLittleEndian ) = bs.Read( kBlockSize )		    		    // Figure out what we need to do with it.  We figure out whether		    // we're dealing with a directory, or a file, or a long file name by		    // looking at the link flag		    select case block.Linkflag		    case "L"		      // This is a long link name, meaning that the file name is > 100 bytes.  The		      // actual data is in the following block.		      if block.Name = "././@LongLink" then		        // Get the size of the real data		        dim size as Integer = Val( "&o" + block.ContentSize )		        name = bs.Read( size )		        		        // Now skip to the end of the block		        bs.Position = bs.Position + kBlockSize - size		      end if		    case "5"		      // We've gotten a directory, so get the name from the name block		      if name = "" then		        name = MyTrim( block.Name  )		      end if		      		      // Now we want to traverse the folder structure to make the 		      // properly-named directory		      dim parts() as String = Split( name, "/" )		      dim toMake as FolderItem = f.Parent		      for each part as String in parts		        if part <> "" then		          toMake = toMake.Child( part )		          		          if toMake = nil then return		          if not toMake.Exists then toMake.CreateAsFolder		        end if		      next part		      name = ""		    case "0"		      // We've gotten a file, so get the name of it from the name block		      if name = "" then		        name = MyTrim( block.Name  )		      end if		      		      // Now we want to traverse the folder structure to make the		      // properly-named file		      dim parts() as String = Split( name, "/" )		      dim toMake as FolderItem = f.Parent		      for each part as String in parts		        if part <> "" then		          toMake = toMake.Child( part )		          		          if toMake = nil then return		        end if		      next part		      		      // Now that we're here, it's time to create the file		      dim out as BinaryStream = toMake.CreateBinaryFile( "????" )		      		      // And write the file out in block chunks		      dim sizeToMake as Integer = Val( "&o" + block.ContentSize )		      out.Write( bs.Read( sizeToMake ) )		      		      // Advance past any padding we wrote out		      while bs.Position mod kBlockSize <> 0		        bs.Position = bs.Position + 1		      wend		      		      out.Close		      toMake.ModificationDate = GetModificationDate( block.ModTime )		      name = ""		    end select		  wend		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function MyTrim(s as String) As String		  // Get rid of spaces		  s = Trim( s )		  		  // Now get read of leading null bytes		  dim pos as Integer = 1		  while Mid( s, pos, 1 ) = Chr( 0 )		    pos = pos + 1		  wend		  if pos > 1 then s = Mid( s, pos )		  		  // And trailing null bytes		  pos = Len( s )		  while Mid( s, pos, 1 ) = Chr( 0 )		    pos = pos - 1		  wend		  if pos < Len( s ) then s = Left( s, pos )		  		  return s		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub TAR(extends f as FolderItem, output as FolderItem)		  if output = nil then return		  		  // TAR is a very simple format, laid out in 512-byte blocks.		  dim bs as BinaryStream = output.CreateBinaryFile( "????" )		  AddToTar( "", bs, f )		  		  // We always pad with two empty blocks of data		  dim mb as new MemoryBlock( 1024 )		  bs.Write( mb )		  bs.Close		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub TarFile(path as String, bs as BinaryStream, f as FolderItem)		  if f.Directory then return		  		  dim dirname as String = path + f.Name		  dim block as Header		  		  WriteTarName( dirname, block, bs )		  block.Mode = GetFilledOctValue( f.Permissions, 8 )		  block.UserID = GetFilledOctValue( 0, 8 )		  block.GroupID = GetFilledOctValue( 0, 8 )		  block.ContentSize = GetFilledOctValue( f.Length, 12 )		  WriteTimestamp( f, block )		  block.Linkflag = "0"		  block.Magic = "ustar  " + Chr( 0 )		  ComputeChecksum( block )		  		  bs.Write( block.StringValue( TargetLittleEndian ) )		  		  // Write the file's data next		  dim fileData as BinaryStream = f.OpenAsBinaryFile( false )		  if fileData <> nil then		    while not fileData.EOF		      bs.Write( fileData.Read( kBlockSize ) )		    wend		    		    // Make sure we're aligned to a 512 byte boundary		    dim paddingLength as UInt32 = kBlockSize - (fileData.Length And &h00000000000001FF)		    if paddingLength > 0 and paddingLength < 512 then		      dim mb as new MemoryBlock( paddingLength )		      bs.Write( mb )		    end if		    fileData.Close		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub TarFolder(path as String, bs as BinaryStream, f as FolderItem)		  if not f.Directory then return		  		  dim dirname as String = path + f.Name + "/"		  dim block as Header		  		  WriteTarName( dirname, block, bs )		  block.Mode = GetFilledOctValue( &o755, 8 )		  block.UserID = GetFilledOctValue( 0, 8 )		  block.GroupID = GetFilledOctValue( 0, 8 )		  block.ContentSize = GetFilledOctValue( 0, 12 )		  WriteTimestamp( f, block )		  block.Linkflag = "5"		  block.Magic = "ustar  " + Chr( 0 )		  ComputeChecksum( block )		  		  bs.Write( block.StringValue( TargetLittleEndian ) )		  		  // Write all of the children out next		  dim count as Integer = f.Count		  for i as Integer = 1 to count		    AddToTar( dirname, bs, f.Item( i ) )		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetFilledOctValue(value as Integer, size as Integer) As String		  dim valAsOct as String = Oct( value )		  size = size - 1		  if Len( valAsOct ) > size then		    valAsOct = Right( valAsOct, size )		  else		    while Len( valAsOct ) < size		      valAsOct = "0" + valAsOct		    wend		  end		  		  return valAsOct + Chr( 0 )		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub WriteTimestamp(theFile as FolderItem, ByRef block as Header)		  // We need to convert the REALbasic modification date (Jan 1, 1904)		  // to be a UNIX modification date (Jan 1, 1970)		  dim modDate as Double = theFile.ModificationDate.TotalSeconds - 2082844800.0		  block.ModTime = GetFilledOctValue( modDate, 12 )		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ComputeChecksum(ByRef block as Header)		  // When computing the checksum, it should be filled with		  // blanks first		  block.Checksum = "        " // 8 spaces		  		  dim sum as Int32		  dim mb as MemoryBlock = block.StringValue( TargetLittleEndian )		  		  for i as Integer = 0 to kBlockSize - 1		    sum = sum + mb.UInt8Value( i )		  next i		  		  block.Checksum = GetFilledOctValue( sum, 8 )		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub WriteTarName(name as String, ByRef block as Header, bs as BinaryStream)		  name = ConvertEncoding( name, Encodings.UTF8 ) + Chr( 0 )		  		  'if InStr( name, "FrameworkConsoleMacCarboni386.o" ) <> 0 then Break		  if LenB( name ) <= 100 then		    // This is a very easy one -- just copy the name into the block		    // header		    block.Name = Left( name, 100 )		  else		    // We have to make a "long link"		    dim link as Header		    link.Name = "././@LongLink"		    link.Mode = GetFilledOctValue( &o644, 8 )		    link.UserID = GetFilledOctValue( 0, 8 )		    link.GroupID = GetFilledOctValue( 0, 8 )		    link.ContentSize = GetFilledOctValue( LenB( name ), 12 )		    link.ModTime = GetFilledOctValue( 0, 12 )		    link.Linkflag = "L"		    link.Magic = "ustar  " + Chr( 0 )		    ComputeChecksum( link )		    // Write out the link		    bs.Write( link.StringValue( TargetLittleEndian ) )		    // Write out the name		    bs.Write( name )		    // Pad to 512 bytes		    dim paddingLength as UInt32 = kBlockSize - (LenB( name ) And &h01FF)		    if paddingLength > 0 and paddingLength < 512 then		      dim mb as new MemoryBlock( paddingLength )		      bs.Write( mb )		    end if		    		    block.Name = Left( name, 100 )		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub AddToTar(name as String, bs as BinaryStream, file as FolderItem)		  if file = nil then return		  		  if bs.Position Mod 512 <> 0 then Break		  		  if file.Directory then		    TarFolder( name, bs, file )		  else		    TarFile( name, bs, file )		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetModificationDate(timestamp as String) As Date		  // Convert the timestamp from an Octal string to an actual number with		  // the RB epoch		  dim modDate as Double = Val( "&o" + timestamp ) + 2082844800.0		  dim d as new Date		  d.TotalSeconds = modDate		  return d		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub TAR(f() as FolderItem, Output As Folderitem)		  //This tars up an array of files.		  		  if output = nil then return		  		  // TAR is a very simple format, laid out in 512-byte blocks.		  dim bs as BinaryStream = output.CreateBinaryFile( "????" )		  		  For Each element As FolderItem In f 		    AddToTar( "", bs, element )		    		    // We always pad with two empty blocks of data		    dim mb as new MemoryBlock( 1024 )		    bs.Write( mb )		    		  Next		  		  bs.Close		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub UnTAR(extends f as FolderItem, output as folderitem)		  //This method outputs to a specific folder rather than the archive's parent.		  		  // The TAR format is laid out in 512 byte blocks.  So we want		  // to read the file in, 512 bytes at a time, so that we can decipher it		  // All of the fields are strings, so we don't have to worry about endian		  // issues. Yay!		  dim bs as BinaryStream = f.OpenAsBinaryFile( false )		  if bs = nil then return		  		  // Sometime we need to keep track of long paths and file		  // names.  We do that by using this variable.  If we got a long		  // link name, then name will contain the actual data.  This		  // variable is reset each time we get a directory or file block.		  dim name as String		  while not bs.EOF		    // Read in the header		    dim block as Header		    block.StringValue( TargetLittleEndian ) = bs.Read( kBlockSize )		    		    // Figure out what we need to do with it.  We figure out whether		    // we're dealing with a directory, or a file, or a long file name by		    // looking at the link flag		    select case block.Linkflag		    case "L"		      // This is a long link name, meaning that the file name is > 100 bytes.  The		      // actual data is in the following block.		      if block.Name = "././@LongLink" then		        // Get the size of the real data		        dim size as Integer = Val( "&o" + block.ContentSize )		        name = bs.Read( size )		        		        // Now skip to the end of the block		        bs.Position = bs.Position + kBlockSize - size		      end if		    case "5"		      // We've gotten a directory, so get the name from the name block		      if name = "" then		        name = MyTrim( block.Name  )		      end if		      		      // Now we want to traverse the folder structure to make the		      // properly-named directory		      dim parts() as String = Split( name, "/" )		      dim toMake as FolderItem = output		      for each part as String in parts		        if part <> "" then		          toMake = toMake.Child( part )		          		          if toMake = nil then return		          if not toMake.Exists then toMake.CreateAsFolder		        end if		      next part		      name = ""		    case "0"		      // We've gotten a file, so get the name of it from the name block		      if name = "" then		        name = MyTrim( block.Name  )		      end if		      		      // Now we want to traverse the folder structure to make the		      // properly-named file		      dim parts() as String = Split( name, "/" )		      dim toMake as FolderItem = output		      for each part as String in parts		        if part <> "" then		          toMake = toMake.Child( part )		          		          if toMake = nil then return		        end if		      next part		      		      // Now that we're here, it's time to create the file		      dim out as BinaryStream = toMake.CreateBinaryFile( "????" )		      		      // And write the file out in block chunks		      dim sizeToMake as Integer = Val( "&o" + block.ContentSize )		      out.Write( bs.Read( sizeToMake ) )		      		      // Advance past any padding we wrote out		      while bs.Position mod kBlockSize <> 0		        bs.Position = bs.Position + 1		      wend		      		      out.Close		      toMake.ModificationDate = GetModificationDate( block.ModTime )		      name = ""		    end select		  wend		End Sub	#tag EndMethod	#tag Constant, Name = kBlockSize, Type = Double, Dynamic = False, Default = \"512", Scope = Private	#tag EndConstant	#tag Structure, Name = Header, Flags = &h21		Name as String * 100		  Mode as String * 8		  UserID as String * 8		  GroupID as String * 8		  ContentSize as String * 12		  ModTime as String * 12		  Checksum as String * 8		  Linkflag as String * 1		  Linkname as String * 100		  Magic as String * 8		  UserName as String * 32		  GroupName as String * 32		  DevMajor as String * 8		  DevMinor as String * 8		  Prefix as String * 155		Padding as String * 12	#tag EndStructure	#tag ViewBehavior		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Module#tag EndModule